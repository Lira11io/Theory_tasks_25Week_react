<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="styles/style.css" />
    <title>Ответы по теории 25 неделя. "Жизненный цикл компонента"</title>
  </head>
  <body>
    <div class="root">
      <h1>Привет, Кот. Мои ответы по теории за 25 неделю.</h1>
      <ol>
        <li>
          <span class="question"
            >В компонент передаются атрибуты description и title . Могу ли я их
            сложить как на примере, чтобы получить одну строку и вывести в
            компоненте?<br />
            <img src="styles/img/1que.png" alt="1 вопрос" />
          </span>
          <p>
            Ответ: Оператор сложения с присваиванием (+=) добавляет значение
            правого операнда к переменной и присваивает переменной результат.
            Таким образом, мы присвоим переменной title значение равное title +
            description и выведем его в span.
          </p>
        </li>
        <li>
          <span class="question"
            >С помощью какого метода можно отловить изменение props?</span
          >
          <p>
            Ответ: UNSAFE_componentWillReceiveProps(nextProps). Этот метод
            вызывается каждый раз, когда компонент получает новые значения
            props. Вы можете сравнить текущие и новые значения props и выполнить
            нужные действия в зависимости от изменений.
          </p>
        </li>
        <li>
          <span class="question"
            >Оператор расширения часто используется также для клонирования
            объекта. Подумайте, чем отличаются эти две записи и какую проблему
            решает здесь оператор расширения:<br />
            <img src="styles/img/3que.png" alt="3 вопрос" />
          </span>
          <p>
            Ответ: объекты в JavaScript являются ссылочными значениями, их
            нельзя просто скопировать с помощью =. При использовании =,
            указатель копируется в область занимаемой памяти. И при попытке
            внести изменения в новый объект, такие же изменения будут внесены в
            первоначальный объект. При помощи spread suntax (...) происходит
            клонирование объекта, и изменение нового объекта не вызывает
            изменения исходного. Правда такое клонирование - поверхностное и не
            подходит для вложенных или многомерных объектов и массивов.
          </p>
        </li>
        <li>
          <span class="question"
            >В каком из методов жизненного цикла лучше всего использовать методы
            вызова API и обращения к веб-хранилищам, если они должны быть
            вызваны всего один раз при загрузке страницы?</span
          >
          <p>Ответ: componentDidMount()</p>
        </li>
        <li>
          <span class="question"
            >С помощью какого метода можно отловить и отрисовать для
            пользователя возникшую в компоненте ошибку?</span
          >
          <p>
            Ответ: static getDerivedStateFromError(error) и
            componentDidCatch(error, info). Используйте static
            getDerivedStateFromError() при рендеринге запасного UI в случае
            отлова ошибки. Используйте componentDidCatch() при написании кода
            для журналирования информации об отловленной ошибке.
          </p>
        </li>
        <li>
          <span class="question"
            >Какой код обычно пишут в конструкторе? Для каких задач он
            используется?</span
          >
          <p>
            Ответ: <br />
            constructor(props) {<br />
            super(props);<br />
            this.state = { date : new Date(), <br />
            clickedStatus: false }; }<br />
            Используется для инициализации (создании) компонента, для
            установления первоначального состояния и для привязка обработчиков
            событий к экземпляру.
          </p>
        </li>
        <li>
          <span class="question"
            >Что делает функция render()? Что может её вызвать?</span
          >
          <p>
            Ответ: Задачей этой функции является определение того, что будет
            выведено на экран, то есть того, как будет выглядеть компонент.
            Функция render() в процессе жизни компонента может быть вызвана
            множество раз. Так, когда React определяет, что что-то, относящееся
            к компоненту, изменилось, наподобие состояния или свойств, то есть
            что-то такое, что может повлиять на внешний вид компонента, React
            может вызвать этот метод.
          </p>
        </li>
        <li>
          <span class="question"
            >Что нужно изменить в коде из урока (видео), чтобы начальные
            параметры у компонента приходили из пропсов, но если пропсы вообще
            не заданы, начальные значения были инициализированы нулями?</span
          >
          <p>
            Ответ: <img src="styles/img/8que.png" alt="решение 8 вопроса" />
          </p>
        </li>
        <li>
          <span class="question"
            >Можно ли несколько раз использовать хук useEffect внутри одного
            компонента?</span
          >
          <p>
            Ответ: Для нескольких задач можно использовать несколько useEffect
            для одного и того же компонента. Можно разделить работу на части и
            назначить useEffect для каждой. Назначение useEffect на короткие и
            одноцелевые функции предотвращает нежелательную повторную
            визуализацию и позволяет сохранить код чистым и читабельным.
          </p>
        </li>
        <li>
          <span class="question"
            >Можно ли не передавать второй аргумент в хук useEffect? Что тогда
            произойдёт?</span
          >
          <p>
            Ответ: можно. Сработает функция, переданная в качестве первого
            аргумента. И будет срабатывать каждый раз при рендеринге.
          </p>
        </li>
        <li>
          <span class="question"
            >Что означает возвращение функции в теле хука useEffect?
          </span>
          <p>
            Ответ: Возвращение функции в теле хука useEffect (cleanup-функции)
            означает, что эта функция будет выполнена при очистке
            (отмонтировании) компонента.
          </p>
        </li>
        <li>
          <span class="question"
            >Будут ли перерисованы дочерние элементы компонента при вызове
            метода forceUpdate()?</span
          >
          <p>
            Ответ: да. Вызов forceUpdate() приведет к вызову render() для
            компонента, пропуская shouldComponentUpdate(). Это вызовет обычные
            методы жизненного цикла для дочерних компонентов, включая метод
            shouldComponentUpdate() каждого дочернего компонента. React
            по-прежнему будет обновлять DOM только при изменении разметки.
          </p>
        </li>
      </ol>
      <span class="question"
        >1 практическое задание: Попробуйте переписать классовый компонент
        Counter, используя хуки</span
      >
      <p>
        Ответ:
        <img
          src="styles/img/1practic.png"
          alt="решение 1 практического задания"
        />
      </p>
    </div>
    <script src="index.js"></script>
  </body>
</html>
